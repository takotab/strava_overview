# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_ti.ipynb (unless otherwise specified).

__all__ = ['interpolate', 'moving_average', 'norm_power', 'training_impulse_power', 'Zones', 'training_impulse_hr',
           'get_ftp', 'get_max_heartrate', 'make_ti']

# Cell
from .models import *
import pandas as pd
import numpy as np

# Cell
def interpolate(df):
    df.index = df['time']
    df2 = df.reindex(np.arange(df.index[-1]))
    df2 = df2.interpolate()
    return df2

# Cell
def moving_average(time_series, window_len):
    """Calculates the moving average of an unevenly spaced time series.

    This moving average implementation weights each value by the time it remained
    unchanged, which conceptually matches smart recording on GPS devices: a sample
    is taken when some value changes sufficiently, so before a new sample is taken
    the previous one is assumed to be more or less constant.

    The term "area" below means a sum of time-weighted values.

    This implementation follows the SMA_last algorithm proposed
    in (Eckner, 2017) (see README for citation).

    Args:
    time_series: A pandas.Series of the values to average,
                 indexed with timestamps.
    window_len: The size of the moving average window, in seconds.

    Returns:
    A numpy array of length len(time_series) containing the
    moving average values
    """
    # Re-index the time series with duration in seconds from the first value
#     time_series.index = (
#       (time_series.index
#        - time_series.index[0]) / np.timedelta64(1, 's')).astype('int')

    window_area = time_series.iloc[0] * window_len

    # It may not always be possible to construct a window of length exactly equal
    # to window_len using timestamps present in the data. To handle this, the left
    # side of the window is allowed to fall between timestamps (the right side is
    # always fixed to a timestamp in the data). Therefore we need to separately
    # compute the area of the inter-timestamp region on the left side of the
    # window so that it can be added to the window area. left_area is that value.
    left_area = window_area

    out = np.zeros(len(time_series))
    out[0] = time_series.iloc[0]

    # i is the left side of the window and j is the right
    i = 0
    for j in range(1, len(time_series)):
        # Remove the last iteration's left_area as a new right window bound may
        # change the left_area required in this iteration
        window_area -= left_area

        # Expand window to the right
        window_area += time_series.iloc[j-1] * (time_series.index[j]
                                                - time_series.index[j-1])

        # Shrink window from the left if expanding to the right has created too
        # large a window. new_left_time may fall between timestamps present in the
        # data, which is fine, since that's handled by left_area.
        new_left_time = time_series.index[j] - window_len
        while time_series.index[i] < new_left_time:
            window_area -= time_series.iloc[i] * (time_series.index[i+1]
                                                - time_series.index[i])
            i += 1

        # Add left side inter-timestamp area to window
        left_area = time_series.iloc[max(0, i - 1)] * (time_series.index[i]
                                                       - new_left_time)
        window_area += left_area

        out[j] = window_area / window_len

    return out

# Cell
def norm_power(p):
    return np.sqrt(np.sqrt(np.mean(moving_average(p, 30) ** 4)))

# Cell
def training_impulse_power(df, ftp):
    norm_p = norm_power(df.watts)
    total_time = sum(df['moving'])
    intesity = norm_p/float(ftp)
    return (total_time*norm_p * intesity)/(float(ftp)*3600.) *100


# Cell
class Zones():
    def __init__(self,max_hr, zones = [.6,.7,.79,.85,.9, 1]):
        self.zones, self.max_hr = zones, max_hr

    def __repr__(self,):
        res = {}
        for k,start,end in zip(range(1,6),self.zones[:-1],self.zones[1:]):
            res[k] = (start*self.max_hr,end*self.max_hr)
        return str(res)

    def __str__(self):
        return self.__repr__()

    def __call__(self, o):
        for i, v in enumerate(self.zones):
            if o < v*self.max_hr:
                return i


# Cell
def training_impulse_hr(df, max_hr):
    hr = df.heartrate
    z = Zones(max_hr)
    norm_hr = pd.Series((moving_average(hr, 15))).apply(z)
    return (np.sum(norm_hr) ) / (4*3600)*100

# Cell
import streamlit as st
def get_ftp(cls):
    at = list(Athlete.query(int(cls.athlete_id)))[0]
    if at.ftp is None:
        at.ftp = st.number_input('Wat is uw ftp?', min_value=0, max_value=500, value = 340)
        at.save()
    return at.ftp
Activity.get_ftp = get_ftp

# Cell
import streamlit as st
def get_max_heartrate(cls):
    at = list(Athlete.query(int(cls.athlete_id)))[0]
    if at.max_heartrate is None:
        at.max_heartrate = st.number_input('Wat is uw maximale hartslag?', min_value=80, max_value=250, value = 190)
        at.save()
    return at.max_heartrate
Activity.get_max_heartrate = get_max_heartrate

# Cell
def make_ti(cls):
    df = cls.get_df()
    if cls.has_heartrate and cls.ti_hr is None:
        cls.ti_hr = training_impulse_hr(df, cls.get_max_heartrate())
        cls.ti = cls.ti_hr
    if cls.device_watts and cls.ti_w is None:
        cls.ti_w = training_impulse_power(df, cls.get_ftp())
        cls.ti = cls.ti_w
    cls.save()
    return {'ti':cls.ti}

Activity.make_ti = make_ti
