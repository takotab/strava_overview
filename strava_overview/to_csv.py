# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_to_csv.ipynb (unless otherwise specified).

__all__ = ['MyServer', 'Handel', 'datetime_fix', 'get_activities', 'get_streams', 'parse_activity', 'parse_activitys']

# Cell
import json

# Cell
import http.server

class MyServer(http.server.BaseHTTPRequestHandler):
  #Handle the web data sent from the strava API
    def do_HEAD(self):
        return self.do_GET()

    def do_GET(self):
        #Get the API code for Strava
#         self.wfile.write('<script>window.close();</script>')
        print(self.path)
        state = {o.split("=")[0]: o.split("=")[1] for o in self.path.split("&")}
        code = state["code"]
        json.dump(state,open('auth_token.json','w'))

# Cell
import stravalib
import urllib.parse
import webbrowser
import os
import pandas as pd
# import datetime

# Cell
class Handel:
    def __init__(self,client_id, secret, port = 5000, url = "http://localhost:xxport/authorized",types = [
            "time",
            "distance",
            "latlng",
            "altitude",
            "velocity_smooth",
            "moving",
            "grade_smooth",
            "temp",
            "watts",
            "cadence",
            "heartrate",
    ]
                ):
        # Create the strava client, and open the web browser for authentication
        self.client_id, self.secret, self.types = client_id, secret, types
        self.client = stravalib.client.Client()
        self.url = url.replace('xxport',str(port))
        self.port = port
        self.authorize_url = self.client.authorization_url(client_id=client_id, redirect_uri=self.url, scope ='activity:read_all')

    def get_auth(self,):

        print("Opening: %s" % self.authorize_url)
        webbrowser.open(self.authorize_url)

        try:
            httpd = http.server.HTTPServer(("localhost", self.port), MyServer)
            httpd.handle_request()
            httpd.server_close()

        except KeyboardInterrupt:
            # Allow ^C to interrupt from any thread.
            sys.stdout.write("\033[0m")
            sys.stdout.write("User Interupt\n")

    def start(self):
        if not os.path.isfile('auth_token.json'):
            self.get_auth()
        state = json.load(open('auth_token.json','r'))
        if 'access_token' not in state:
            try:
                access_token = self.client.exchange_code_for_token(
                client_id=self.client_id, client_secret=self.secret, code=state['code'])
            except Exception as e:
                print(e,'trying new')
                self.get_auth()
                state = json.load(open('auth_token.json','r'))
                access_token = self.client.exchange_code_for_token(
                client_id=self.client_id, client_secret=self.secret, code=state['code'])
            # access_token save here
            state['access_token'] = access_token
            json.dump(state,open('auth_token.json','w'))

        # Now store that access token somewhere (for now, it's just a local variable)
        self.client.access_token = state['access_token']["access_token"]
        self.athlete = self.client.get_athlete()
        print(f"Welcome {self.athlete.firstname} {self.athlete.lastname}")

# Cell
def datetime_fix(start_date, days):
    before = pd.Timestamp(start_date)
    before = pd.Timestamp(before.year,before.month,before.day,23,59)
    before.tz_localize('utc')
    after = before - pd.Timedelta(days=days)
    return before, after

# Cell
def get_activities(self, start_date = None, days = 7):
    start_date = ifnone(start_date, pd.Timestamp.now())
    before, after = datetime_fix(start_date, days)
    # Returns a list of Strava activity objects, up to the number specified by limit
    activities = self.client.get_activities(before = before, after=after)
#     assert len(list(activities)) == limit
    for item in activities:
        print(pd.to_datetime(item.start_date_local))
    return activities
Handel.get_activities = get_activities


# Cell
def get_streams(self, activity, types):
    # Returns a Strava 'stream', which is timeseries data from an activity
    streams = self.client.get_activity_streams(activity, types=types, series_type="time")
    return streams
Handel.get_streams = get_streams

def parse_activity(self, act):
    act_id = act.id
    name = act.name
    print(str(act_id), str(act.name), act.start_date)
    streams = self.get_streams(act_id, self.types)
    df = pd.DataFrame()

    # Write each row to a dataframe
    for item in self.types:
        if item in list(streams.keys()):
            df[item] = pd.Series(streams[item].data, index=None)
        df["act_id"] = act.id
        df["act_startDate"] = pd.to_datetime(act.start_date)
        df["act_name"] = name
    f = str(act_id) + '.csv'
    df.to_csv(f, index=False)
    return df, f
Handel.parse_activity = parse_activity

def parse_activitys(self, activities:[]):
    fs = []
    for act in activities:
        df, f = self.parse_activity(act)
        fs.append(f)
    return fs
Handel.parse_activitys = parse_activitys