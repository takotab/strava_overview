# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_models.ipynb (unless otherwise specified).

__all__ = ['EmailIndex', 'AlreadyFoundExeption', 'IncorrectPassword', 'LockedAccount', 'Athlete', 'types', 'Handel',
           'dagen_van_week', 'types', 'Activity', 'datetime_fix', 'get_activities', 'emoji_name', 'emoji_dct',
           'save_activities']

# Cell
import json
import bcrypt
from fastcore.imports import *
from typing import List, Dict

# Cell
# Global Variables - put your data in the file 'client.secret' and separate the fields with a comma!
# client_id, secret = open("../client.secret").read().strip().split(",")

# Cell
from .imports import *
from .s3 import *
from .auth import *

# Cell
from pynamodb.models import Model
from pynamodb.attributes import (
    UnicodeAttribute, NumberAttribute, UnicodeSetAttribute, UTCDateTimeAttribute, BooleanAttribute, MapAttribute, ListAttribute,
)

# Cell
class EmailIndex(Model):
    """
    This class represents a global secondary index
    """
    class Meta:
        table_name = "motionreview-email"
        region = 'eu-central-1'
        read_capacity_units = 1
        write_capacity_units = 1
    # This attribute is the hash key for the index
    # Note that this attribute must also exist
    # in the model
    email = UnicodeAttribute(hash_key=True)
    id = NumberAttribute()
    password = UnicodeAttribute()
    lock = BooleanAttribute(default = False)

    @classmethod
    def get_(self, email:str, hard =False):
        emls = list(EmailIndex.query(email))
        if len(emls) == 0:
            raise KeyError(email)
        elif len(emls) == 1:
            return emls[0]
        else:
            if hard:
                return emls
            raise KeyError(email)

    @classmethod
    def exists(self, email:str):
        try:
            o = self.get_(email)
            if o is not None:
                return True
        except KeyError:
            return False


# Cell
class AlreadyFoundExeption(Exception):pass
class IncorrectPassword(Exception):pass
class LockedAccount(Exception):pass

# Cell

types = [
            "time",
            "distance",
            "latlng",
            "altitude",
            "velocity_smooth",
            "moving",
            "grade_smooth",
            "temp",
            "watts",
            "cadence",
            "heartrate",
    ]

class Athlete(Model):
    class Meta:
        table_name = "motionreview-athlete"
        region = 'eu-central-1'
    id = NumberAttribute(hash_key=True)
    firstname = UnicodeAttribute()
    lastname = UnicodeAttribute()
    profile = UnicodeAttribute()
    sex = UnicodeAttribute()
    max_heartrate = NumberAttribute(null=True)
    ftp = NumberAttribute(null=True)
    weight = NumberAttribute(null=True)
    zones = ListAttribute(null=True)
    email = UnicodeAttribute(null=True)
    access_token = UnicodeAttribute(null=True)
    refresh_token = UnicodeAttribute(null=True)

    @classmethod
    def from_stravalib(cls, athlete:stravalib.model.Athlete, **kwargs):
        dct = {k:athlete.__getattribute__(k) for k in 'firstname,lastname,profile,sex,max_heartrate,weight,ftp'.split(',') if (athlete.__getattribute__(k) is not None)}
        dct.update(kwargs)
        ath = cls(athlete.id,**dct)
        ath.save()
        return ath

    @classmethod
    def from_id(cls, id =None, **kwargs):
        if id is None:
            return cls.authenticate(**kwargs)
        return Athlete.get_athlete(id = id)

    @staticmethod
    def get_athlete(id = None, ath:stravalib.model.Athlete = None):
        if id is None:
            assert type(ath) == stravalib.model.Athlete
            id = ath.id

        aths =list(Athlete.query(int(id)))
        if len(aths) == 1:
            return aths[0]
        elif len(aths) == 0 and ath is not None:
            return Athlete.from_stravalib(ath)
        else:
            raise IndexError(f"to many athlets with id {ath.id}:{aths}")

    @staticmethod
    def login(email:str, password:str, trys:int):
        emls = EmailIndex.get_(email)
        if emls.lock:
            raise LockedAccount()
        master_secret_key, salt = os.getenv("mastersecret"),os.getenv("SALT")
        print(f"attemted {trys}/10 for {emls.email}")
        combo_password = password + salt + master_secret_key
        if bcrypt.checkpw(combo_password.encode(), emls.password.encode()):
            return Athlete.from_id(emls.id)
        else:
            if trys > 10:
                emls.lock = True
                raise LockedAccount()
            raise IncorrectPassword()

    def add_login(self, email, password, hard = False):
        if EmailIndex.exists(email) and not hard:
            raise AlreadyFoundExeption()
        self.email = email
        self.save()
        master_secret_key, salt = os.getenv("mastersecret"),os.getenv("SALT")
        combo_password = password + salt + master_secret_key
        hashed_password = bcrypt.hashpw(combo_password.encode(), salt.encode())
        e = EmailIndex(email, id = self.id, password = hashed_password.decode())
        e.save()


# Cell
class Handel:
    def __init__(self, ath_id=None):
        self.client = stravalib.client.Client()
        self.athlete = Athlete.get_athlete(id = ath_id)
        self.set_access_token()
        self.strava_athlete = self.client.get_athlete()

    def set_access_token(self):
        client_id, secret = os.getenv("client_id"), os.getenv("secret")
        self.client.access_token = self.athlete.access_token
        try:
            self.strava_athlete = self.client.get_athlete()
            return
        except:
            self.client.access_token = self.client.refresh_access_token(
                client_id=client_id,
                client_secret=secret,
                refresh_token=self.athlete.refresh_token,
            )
        self.strava_athlete = self.client.get_athlete()


# Cell
dagen_van_week = {
    0: "Maandag",
    1: "Dinsdag",
    2: "Woensdag",
    3: "Donderdag",
    4: "Vrijdag",
    5: "Zaterdag",
    6: "Zondag",
}
types = [
            "time",
            "distance",
            "latlng",
            "altitude",
            "velocity_smooth",
            "moving",
            "grade_smooth",
            "temp",
            "watts",
            "cadence",
            "heartrate",
    ]

# Cell
from fastcore.foundation import *
class Activity(Model, GetAttr):
    _default = '_act'
    class Meta:
        table_name = "motionreview-activity"
        region = 'eu-central-1'

    id = UnicodeAttribute(hash_key=True)
    athlete_id = UnicodeAttribute()
    start_date_local = UTCDateTimeAttribute()
    name = UnicodeAttribute()
    act_type = UnicodeAttribute()
    device_watts = BooleanAttribute(default=False)
    has_heartrate = BooleanAttribute(default=False)
    on_s3 = BooleanAttribute(default=False)
    ti = NumberAttribute(null=True)
    ti_w = NumberAttribute(null=True)
    ti_hr = NumberAttribute(null=True)

    @classmethod
    def from_stravalib(cls, act):
        Athlete.get_athlete(ath = act.athlete)
        device = act.device_watts if act.device_watts else False
        activity = cls(id = str(act.id), name = act.name, athlete_id = str(act.athlete.id), act_type = act.type,
                        device_watts=device, start_date_local = act.start_date_local, has_heartrate = act.has_heartrate,
                        )
        activity._act = act
        return activity

    @classmethod
    def from_id(cls, id, h=None):
        activity = get_activity(id = id, h=h)

    @staticmethod
    def get_activity(id = None, act:stravalib.model.Activity = None, h=None):
        if id is None and act is None:
            raise Exception('`id` and `act` can not be `None`')
        if id is None:
            assert type(act) == stravalib.model.Activity
            id = act.id

        acts =list(Activity.query(int(id)))
        if len(acts) == 1:
            if handel is not None:
                acts[0]._act = h.client.get_activity(str(id))
            return acts[0]
        elif len(acts) == 0:
            return Activity.from_stravalib(ath)
        else:
            raise IndexError(f"to many activitys with id {act.id}:{acts}")

    def save_stream(self, h):
        if not self.on_s3:
            streams = h.client.get_activity_streams(self.id, types=types, series_type="time")
            self.download_save(streams)
        self.h = h

    def filename(self):
        if not os.path.isdir(self.athlete_id):
            os.mkdir(self.athlete_id)
        return self.athlete_id +'/'+ self.id + '.csv'

    def download_save(self, streams):
        df = pd.DataFrame()
        f = self.filename()
        # Write each row to a dataframe
        for item in types:
            if item in list(streams.keys()):
                df[item] = pd.Series(streams[item].data, index=None)
            df["act_id"] = self.id
            df["act_name"] = self.name
        df.to_csv(f, index=False)
        upload_file(f)
        self.on_s3 = True
        self.save()

    def get_df(self) -> pd.DataFrame:
        f = self.filename()
        download_file(f)
        return pd.read_csv(f)

    def row(self, callbacks = [], *args, **kwargs) -> Dict:
        dct = {'Dag':dagen_van_week[pd.Timestamp(self.start_date_local).weekday()],
                'Duur':self.elapsed_time,
                'Naam':self.name,
                'Type':self.act_type,
                }
        callbacks = L(callbacks)
        for callback in callbacks:
            dct.update(callback(self, *args, **kwargs))
        return dct

# Cell
def datetime_fix(start_date, days):
    before = pd.Timestamp(start_date)
    before = pd.Timestamp(before.year,before.month,before.day,23,59)
    before.tz_localize('utc')
    after = before - pd.Timedelta(days=days)
    return before, after

# Cell
def get_activities(self, start_date = None, days = 7):
    start_date = ifnone(start_date, pd.Timestamp.now())
    before, after = datetime_fix(start_date, days)
    # Returns a list of Strava activity objects, up to the number specified by limit
    activities = self.client.get_activities(before = before, after=after)
    return [Activity.from_stravalib(item) for item in activities]

Handel.get_activities = get_activities


# Cell

emoji_dct = {"Ride": "🚲",
             "Virtual": "🎮",
             "Weight": "💪",
             "Run": "🏃",
             "Swim": "🏊",
             "IceSkate":"⛸️",
             }

def _add_bike(row):
    for k, v in emoji_dct.items():
        if k in row["Type"]:
            if v not in row["Naam"]:
                row["Naam"] = v + row["Naam"]
    return row

def emoji_name(df):
    df = df.apply(_add_bike, 1)
    return df


# Cell
def save_activities(self, activities:[]):
    for act in activities:
        act.save_stream(self)
    return activities
Handel.save_activities = save_activities